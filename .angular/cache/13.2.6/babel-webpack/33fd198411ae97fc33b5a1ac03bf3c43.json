{"ast":null,"code":"import _asyncToGenerator from \"/home/sparkout/Desktop/Hari/Sparkout/Angular/Angular_ZUKI/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as crypto from \"@walletconnect/crypto\";\nimport * as encoding from \"@walletconnect/encoding\";\nimport { convertArrayBufferToBuffer, convertBufferToArrayBuffer } from \"@walletconnect/utils\";\nexport function generateKey(_x) {\n  return _generateKey.apply(this, arguments);\n}\n\nfunction _generateKey() {\n  _generateKey = _asyncToGenerator(function* (length) {\n    const _length = (length || 256) / 8;\n\n    const bytes = crypto.randomBytes(_length);\n    const result = convertBufferToArrayBuffer(encoding.arrayToBuffer(bytes));\n    return result;\n  });\n  return _generateKey.apply(this, arguments);\n}\n\nexport function verifyHmac(_x2, _x3) {\n  return _verifyHmac.apply(this, arguments);\n}\n\nfunction _verifyHmac() {\n  _verifyHmac = _asyncToGenerator(function* (payload, key) {\n    const cipherText = encoding.hexToArray(payload.data);\n    const iv = encoding.hexToArray(payload.iv);\n    const hmac = encoding.hexToArray(payload.hmac);\n    const hmacHex = encoding.arrayToHex(hmac, false);\n    const unsigned = encoding.concatArrays(cipherText, iv);\n    const chmac = yield crypto.hmacSha256Sign(key, unsigned);\n    const chmacHex = encoding.arrayToHex(chmac, false);\n\n    if (encoding.removeHexPrefix(hmacHex) === encoding.removeHexPrefix(chmacHex)) {\n      return true;\n    }\n\n    return false;\n  });\n  return _verifyHmac.apply(this, arguments);\n}\n\nexport function encrypt(_x4, _x5, _x6) {\n  return _encrypt.apply(this, arguments);\n}\n\nfunction _encrypt() {\n  _encrypt = _asyncToGenerator(function* (data, key, providedIv) {\n    const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n\n    const ivArrayBuffer = providedIv || (yield generateKey(128));\n    const iv = encoding.bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));\n    const ivHex = encoding.arrayToHex(iv, false);\n    const contentString = JSON.stringify(data);\n    const content = encoding.utf8ToArray(contentString);\n    const cipherText = yield crypto.aesCbcEncrypt(iv, _key, content);\n    const cipherTextHex = encoding.arrayToHex(cipherText, false);\n    const unsigned = encoding.concatArrays(cipherText, iv);\n    const hmac = yield crypto.hmacSha256Sign(_key, unsigned);\n    const hmacHex = encoding.arrayToHex(hmac, false);\n    return {\n      data: cipherTextHex,\n      hmac: hmacHex,\n      iv: ivHex\n    };\n  });\n  return _encrypt.apply(this, arguments);\n}\n\nexport function decrypt(_x7, _x8) {\n  return _decrypt.apply(this, arguments);\n}\n\nfunction _decrypt() {\n  _decrypt = _asyncToGenerator(function* (payload, key) {\n    const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n\n    if (!_key) {\n      throw new Error(\"Missing key: required for decryption\");\n    }\n\n    const verified = yield verifyHmac(payload, _key);\n\n    if (!verified) {\n      return null;\n    }\n\n    const cipherText = encoding.hexToArray(payload.data);\n    const iv = encoding.hexToArray(payload.iv);\n    const buffer = yield crypto.aesCbcDecrypt(iv, _key, cipherText);\n    const utf8 = encoding.arrayToUtf8(buffer);\n    let data;\n\n    try {\n      data = JSON.parse(utf8);\n    } catch (error) {\n      return null;\n    }\n\n    return data;\n  });\n  return _decrypt.apply(this, arguments);\n}","map":{"version":3,"sources":["/home/sparkout/Desktop/Hari/Sparkout/Angular/Angular_ZUKI/node_modules/@walletconnect/iso-crypto/dist/esm/index.js"],"names":["crypto","encoding","convertArrayBufferToBuffer","convertBufferToArrayBuffer","generateKey","length","_length","bytes","randomBytes","result","arrayToBuffer","verifyHmac","payload","key","cipherText","hexToArray","data","iv","hmac","hmacHex","arrayToHex","unsigned","concatArrays","chmac","hmacSha256Sign","chmacHex","removeHexPrefix","encrypt","providedIv","_key","bufferToArray","ivArrayBuffer","ivHex","contentString","JSON","stringify","content","utf8ToArray","aesCbcEncrypt","cipherTextHex","decrypt","Error","verified","buffer","aesCbcDecrypt","utf8","arrayToUtf8","parse","error"],"mappings":"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","sourcesContent":["import * as crypto from \"@walletconnect/crypto\";\nimport * as encoding from \"@walletconnect/encoding\";\nimport { convertArrayBufferToBuffer, convertBufferToArrayBuffer } from \"@walletconnect/utils\";\nexport async function generateKey(length) {\n    const _length = (length || 256) / 8;\n    const bytes = crypto.randomBytes(_length);\n    const result = convertBufferToArrayBuffer(encoding.arrayToBuffer(bytes));\n    return result;\n}\nexport async function verifyHmac(payload, key) {\n    const cipherText = encoding.hexToArray(payload.data);\n    const iv = encoding.hexToArray(payload.iv);\n    const hmac = encoding.hexToArray(payload.hmac);\n    const hmacHex = encoding.arrayToHex(hmac, false);\n    const unsigned = encoding.concatArrays(cipherText, iv);\n    const chmac = await crypto.hmacSha256Sign(key, unsigned);\n    const chmacHex = encoding.arrayToHex(chmac, false);\n    if (encoding.removeHexPrefix(hmacHex) === encoding.removeHexPrefix(chmacHex)) {\n        return true;\n    }\n    return false;\n}\nexport async function encrypt(data, key, providedIv) {\n    const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n    const ivArrayBuffer = providedIv || (await generateKey(128));\n    const iv = encoding.bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));\n    const ivHex = encoding.arrayToHex(iv, false);\n    const contentString = JSON.stringify(data);\n    const content = encoding.utf8ToArray(contentString);\n    const cipherText = await crypto.aesCbcEncrypt(iv, _key, content);\n    const cipherTextHex = encoding.arrayToHex(cipherText, false);\n    const unsigned = encoding.concatArrays(cipherText, iv);\n    const hmac = await crypto.hmacSha256Sign(_key, unsigned);\n    const hmacHex = encoding.arrayToHex(hmac, false);\n    return {\n        data: cipherTextHex,\n        hmac: hmacHex,\n        iv: ivHex,\n    };\n}\nexport async function decrypt(payload, key) {\n    const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n    if (!_key) {\n        throw new Error(\"Missing key: required for decryption\");\n    }\n    const verified = await verifyHmac(payload, _key);\n    if (!verified) {\n        return null;\n    }\n    const cipherText = encoding.hexToArray(payload.data);\n    const iv = encoding.hexToArray(payload.iv);\n    const buffer = await crypto.aesCbcDecrypt(iv, _key, cipherText);\n    const utf8 = encoding.arrayToUtf8(buffer);\n    let data;\n    try {\n        data = JSON.parse(utf8);\n    }\n    catch (error) {\n        return null;\n    }\n    return data;\n}\n"]},"metadata":{},"sourceType":"module"}