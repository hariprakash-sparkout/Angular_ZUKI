{"ast":null,"code":"import _asyncToGenerator from \"/home/sparkout/Desktop/Hari/Sparkout/Angular/Angular_ZUKI/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { parsePersonalSign, parseTransactionData, convertArrayBufferToHex, convertHexToArrayBuffer, getClientMeta, payloadId, uuid, formatRpcError, parseWalletConnectUri, convertNumberToHex, isJsonRpcResponseSuccess, isJsonRpcResponseError, isSilentPayload, getLocal, signingMethods, mobileLinkChoiceKey, isMobile, removeLocal } from \"@walletconnect/utils\";\nimport SocketTransport from \"@walletconnect/socket-transport\";\nimport { ERROR_SESSION_CONNECTED, ERROR_SESSION_DISCONNECTED, ERROR_SESSION_REJECTED, ERROR_MISSING_JSON_RPC, ERROR_MISSING_RESULT, ERROR_MISSING_ERROR, ERROR_MISSING_METHOD, ERROR_MISSING_ID, ERROR_INVALID_RESPONSE, ERROR_INVALID_URI, ERROR_MISSING_REQUIRED, ERROR_QRCODE_MODAL_NOT_PROVIDED, ERROR_QRCODE_MODAL_USER_CLOSED } from \"./errors\";\nimport EventManager from \"./events\";\nimport SessionStorage from \"./storage\";\nimport { getBridgeUrl } from \"./url\";\n\nclass Connector {\n  constructor(opts) {\n    this.protocol = \"wc\";\n    this.version = 1;\n    this._bridge = \"\";\n    this._key = null;\n    this._clientId = \"\";\n    this._clientMeta = null;\n    this._peerId = \"\";\n    this._peerMeta = null;\n    this._handshakeId = 0;\n    this._handshakeTopic = \"\";\n    this._connected = false;\n    this._accounts = [];\n    this._chainId = 0;\n    this._networkId = 0;\n    this._rpcUrl = \"\";\n    this._eventManager = new EventManager();\n    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;\n    this._cryptoLib = opts.cryptoLib;\n    this._sessionStorage = opts.sessionStorage || new SessionStorage(opts.connectorOpts.storageId);\n    this._qrcodeModal = opts.connectorOpts.qrcodeModal;\n    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;\n    this._signingMethods = [...signingMethods, ...(opts.connectorOpts.signingMethods || [])];\n\n    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {\n      throw new Error(ERROR_MISSING_REQUIRED);\n    }\n\n    if (opts.connectorOpts.bridge) {\n      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);\n    }\n\n    if (opts.connectorOpts.uri) {\n      this.uri = opts.connectorOpts.uri;\n    }\n\n    const session = opts.connectorOpts.session || this._getStorageSession();\n\n    if (session) {\n      this.session = session;\n    }\n\n    if (this.handshakeId) {\n      this._subscribeToSessionResponse(this.handshakeId, \"Session request rejected\");\n    }\n\n    this._transport = opts.transport || new SocketTransport({\n      protocol: this.protocol,\n      version: this.version,\n      url: this.bridge,\n      subscriptions: [this.clientId]\n    });\n\n    this._subscribeToInternalEvents();\n\n    this._initTransport();\n\n    if (opts.connectorOpts.uri) {\n      this._subscribeToSessionRequest();\n    }\n\n    if (opts.pushServerOpts) {\n      this._registerPushServer(opts.pushServerOpts);\n    }\n  }\n\n  set bridge(value) {\n    if (!value) {\n      return;\n    }\n\n    this._bridge = value;\n  }\n\n  get bridge() {\n    return this._bridge;\n  }\n\n  set key(value) {\n    if (!value) {\n      return;\n    }\n\n    const key = convertHexToArrayBuffer(value);\n    this._key = key;\n  }\n\n  get key() {\n    if (this._key) {\n      const key = convertArrayBufferToHex(this._key, true);\n      return key;\n    }\n\n    return \"\";\n  }\n\n  set clientId(value) {\n    if (!value) {\n      return;\n    }\n\n    this._clientId = value;\n  }\n\n  get clientId() {\n    let clientId = this._clientId;\n\n    if (!clientId) {\n      clientId = this._clientId = uuid();\n    }\n\n    return this._clientId;\n  }\n\n  set peerId(value) {\n    if (!value) {\n      return;\n    }\n\n    this._peerId = value;\n  }\n\n  get peerId() {\n    return this._peerId;\n  }\n\n  set clientMeta(value) {}\n\n  get clientMeta() {\n    let clientMeta = this._clientMeta;\n\n    if (!clientMeta) {\n      clientMeta = this._clientMeta = getClientMeta();\n    }\n\n    return clientMeta;\n  }\n\n  set peerMeta(value) {\n    this._peerMeta = value;\n  }\n\n  get peerMeta() {\n    const peerMeta = this._peerMeta;\n    return peerMeta;\n  }\n\n  set handshakeTopic(value) {\n    if (!value) {\n      return;\n    }\n\n    this._handshakeTopic = value;\n  }\n\n  get handshakeTopic() {\n    return this._handshakeTopic;\n  }\n\n  set handshakeId(value) {\n    if (!value) {\n      return;\n    }\n\n    this._handshakeId = value;\n  }\n\n  get handshakeId() {\n    return this._handshakeId;\n  }\n\n  get uri() {\n    const _uri = this._formatUri();\n\n    return _uri;\n  }\n\n  set uri(value) {\n    if (!value) {\n      return;\n    }\n\n    const {\n      handshakeTopic,\n      bridge,\n      key\n    } = this._parseUri(value);\n\n    this.handshakeTopic = handshakeTopic;\n    this.bridge = bridge;\n    this.key = key;\n  }\n\n  set chainId(value) {\n    this._chainId = value;\n  }\n\n  get chainId() {\n    const chainId = this._chainId;\n    return chainId;\n  }\n\n  set networkId(value) {\n    this._networkId = value;\n  }\n\n  get networkId() {\n    const networkId = this._networkId;\n    return networkId;\n  }\n\n  set accounts(value) {\n    this._accounts = value;\n  }\n\n  get accounts() {\n    const accounts = this._accounts;\n    return accounts;\n  }\n\n  set rpcUrl(value) {\n    this._rpcUrl = value;\n  }\n\n  get rpcUrl() {\n    const rpcUrl = this._rpcUrl;\n    return rpcUrl;\n  }\n\n  set connected(value) {}\n\n  get connected() {\n    return this._connected;\n  }\n\n  set pending(value) {}\n\n  get pending() {\n    return !!this._handshakeTopic;\n  }\n\n  get session() {\n    return {\n      connected: this.connected,\n      accounts: this.accounts,\n      chainId: this.chainId,\n      bridge: this.bridge,\n      key: this.key,\n      clientId: this.clientId,\n      clientMeta: this.clientMeta,\n      peerId: this.peerId,\n      peerMeta: this.peerMeta,\n      handshakeId: this.handshakeId,\n      handshakeTopic: this.handshakeTopic\n    };\n  }\n\n  set session(value) {\n    if (!value) {\n      return;\n    }\n\n    this._connected = value.connected;\n    this.accounts = value.accounts;\n    this.chainId = value.chainId;\n    this.bridge = value.bridge;\n    this.key = value.key;\n    this.clientId = value.clientId;\n    this.clientMeta = value.clientMeta;\n    this.peerId = value.peerId;\n    this.peerMeta = value.peerMeta;\n    this.handshakeId = value.handshakeId;\n    this.handshakeTopic = value.handshakeTopic;\n  }\n\n  on(event, callback) {\n    const eventEmitter = {\n      event,\n      callback\n    };\n\n    this._eventManager.subscribe(eventEmitter);\n  }\n\n  off(event) {\n    this._eventManager.unsubscribe(event);\n  }\n\n  createInstantRequest(instantRequest) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this._key = yield _this._generateKey();\n\n      const request = _this._formatRequest({\n        method: \"wc_instantRequest\",\n        params: [{\n          peerId: _this.clientId,\n          peerMeta: _this.clientMeta,\n          request: _this._formatRequest(instantRequest)\n        }]\n      });\n\n      _this.handshakeId = request.id;\n      _this.handshakeTopic = uuid();\n\n      _this._eventManager.trigger({\n        event: \"display_uri\",\n        params: [_this.uri]\n      });\n\n      _this.on(\"modal_closed\", () => {\n        throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);\n      });\n\n      const endInstantRequest = () => {\n        _this.killSession();\n      };\n\n      try {\n        const result = yield _this._sendCallRequest(request);\n\n        if (result) {\n          endInstantRequest();\n        }\n\n        return result;\n      } catch (error) {\n        endInstantRequest();\n        throw error;\n      }\n    })();\n  }\n\n  connect(opts) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this2._qrcodeModal) {\n        throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);\n      }\n\n      if (_this2.connected) {\n        return {\n          chainId: _this2.chainId,\n          accounts: _this2.accounts\n        };\n      }\n\n      yield _this2.createSession(opts);\n      return new Promise( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (resolve, reject) {\n          _this2.on(\"modal_closed\", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));\n\n          _this2.on(\"connect\", (error, payload) => {\n            if (error) {\n              return reject(error);\n            }\n\n            resolve(payload.params[0]);\n          });\n        });\n\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n\n  createSession(opts) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this3._connected) {\n        throw new Error(ERROR_SESSION_CONNECTED);\n      }\n\n      if (_this3.pending) {\n        return;\n      }\n\n      _this3._key = yield _this3._generateKey();\n\n      const request = _this3._formatRequest({\n        method: \"wc_sessionRequest\",\n        params: [{\n          peerId: _this3.clientId,\n          peerMeta: _this3.clientMeta,\n          chainId: opts && opts.chainId ? opts.chainId : null\n        }]\n      });\n\n      _this3.handshakeId = request.id;\n      _this3.handshakeTopic = uuid();\n\n      _this3._sendSessionRequest(request, \"Session update rejected\", {\n        topic: _this3.handshakeTopic\n      });\n\n      _this3._eventManager.trigger({\n        event: \"display_uri\",\n        params: [_this3.uri]\n      });\n    })();\n  }\n\n  approveSession(sessionStatus) {\n    if (this._connected) {\n      throw new Error(ERROR_SESSION_CONNECTED);\n    }\n\n    this.chainId = sessionStatus.chainId;\n    this.accounts = sessionStatus.accounts;\n    this.networkId = sessionStatus.networkId || 0;\n    this.rpcUrl = sessionStatus.rpcUrl || \"\";\n    const sessionParams = {\n      approved: true,\n      chainId: this.chainId,\n      networkId: this.networkId,\n      accounts: this.accounts,\n      rpcUrl: this.rpcUrl,\n      peerId: this.clientId,\n      peerMeta: this.clientMeta\n    };\n    const response = {\n      id: this.handshakeId,\n      jsonrpc: \"2.0\",\n      result: sessionParams\n    };\n\n    this._sendResponse(response);\n\n    this._connected = true;\n\n    this._setStorageSession();\n\n    this._eventManager.trigger({\n      event: \"connect\",\n      params: [{\n        peerId: this.peerId,\n        peerMeta: this.peerMeta,\n        chainId: this.chainId,\n        accounts: this.accounts\n      }]\n    });\n  }\n\n  rejectSession(sessionError) {\n    if (this._connected) {\n      throw new Error(ERROR_SESSION_CONNECTED);\n    }\n\n    const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;\n\n    const response = this._formatResponse({\n      id: this.handshakeId,\n      error: {\n        message\n      }\n    });\n\n    this._sendResponse(response);\n\n    this._connected = false;\n\n    this._eventManager.trigger({\n      event: \"disconnect\",\n      params: [{\n        message\n      }]\n    });\n\n    this._removeStorageSession();\n  }\n\n  updateSession(sessionStatus) {\n    if (!this._connected) {\n      throw new Error(ERROR_SESSION_DISCONNECTED);\n    }\n\n    this.chainId = sessionStatus.chainId;\n    this.accounts = sessionStatus.accounts;\n    this.networkId = sessionStatus.networkId || 0;\n    this.rpcUrl = sessionStatus.rpcUrl || \"\";\n    const sessionParams = {\n      approved: true,\n      chainId: this.chainId,\n      networkId: this.networkId,\n      accounts: this.accounts,\n      rpcUrl: this.rpcUrl\n    };\n\n    const request = this._formatRequest({\n      method: \"wc_sessionUpdate\",\n      params: [sessionParams]\n    });\n\n    this._sendSessionRequest(request, \"Session update rejected\");\n\n    this._eventManager.trigger({\n      event: \"session_update\",\n      params: [{\n        chainId: this.chainId,\n        accounts: this.accounts\n      }]\n    });\n\n    this._manageStorageSession();\n  }\n\n  killSession(sessionError) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const message = sessionError ? sessionError.message : \"Session Disconnected\";\n      const sessionParams = {\n        approved: false,\n        chainId: null,\n        networkId: null,\n        accounts: null\n      };\n\n      const request = _this4._formatRequest({\n        method: \"wc_sessionUpdate\",\n        params: [sessionParams]\n      });\n\n      yield _this4._sendRequest(request);\n\n      _this4._handleSessionDisconnect(message);\n    })();\n  }\n\n  sendTransaction(tx) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this5._connected) {\n        throw new Error(ERROR_SESSION_DISCONNECTED);\n      }\n\n      const parsedTx = parseTransactionData(tx);\n\n      const request = _this5._formatRequest({\n        method: \"eth_sendTransaction\",\n        params: [parsedTx]\n      });\n\n      const result = yield _this5._sendCallRequest(request);\n      return result;\n    })();\n  }\n\n  signTransaction(tx) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this6._connected) {\n        throw new Error(ERROR_SESSION_DISCONNECTED);\n      }\n\n      const parsedTx = parseTransactionData(tx);\n\n      const request = _this6._formatRequest({\n        method: \"eth_signTransaction\",\n        params: [parsedTx]\n      });\n\n      const result = yield _this6._sendCallRequest(request);\n      return result;\n    })();\n  }\n\n  signMessage(params) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this7._connected) {\n        throw new Error(ERROR_SESSION_DISCONNECTED);\n      }\n\n      const request = _this7._formatRequest({\n        method: \"eth_sign\",\n        params\n      });\n\n      const result = yield _this7._sendCallRequest(request);\n      return result;\n    })();\n  }\n\n  signPersonalMessage(params) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this8._connected) {\n        throw new Error(ERROR_SESSION_DISCONNECTED);\n      }\n\n      params = parsePersonalSign(params);\n\n      const request = _this8._formatRequest({\n        method: \"personal_sign\",\n        params\n      });\n\n      const result = yield _this8._sendCallRequest(request);\n      return result;\n    })();\n  }\n\n  signTypedData(params) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this9._connected) {\n        throw new Error(ERROR_SESSION_DISCONNECTED);\n      }\n\n      const request = _this9._formatRequest({\n        method: \"eth_signTypedData\",\n        params\n      });\n\n      const result = yield _this9._sendCallRequest(request);\n      return result;\n    })();\n  }\n\n  updateChain(chainParams) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this10._connected) {\n        throw new Error(\"Session currently disconnected\");\n      }\n\n      const request = _this10._formatRequest({\n        method: \"wallet_updateChain\",\n        params: [chainParams]\n      });\n\n      const result = yield _this10._sendCallRequest(request);\n      return result;\n    })();\n  }\n\n  unsafeSend(request, options) {\n    this._sendRequest(request, options);\n\n    this._eventManager.trigger({\n      event: \"call_request_sent\",\n      params: [{\n        request,\n        options\n      }]\n    });\n\n    return new Promise((resolve, reject) => {\n      this._subscribeToResponse(request.id, (error, payload) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        if (!payload) {\n          throw new Error(ERROR_MISSING_JSON_RPC);\n        }\n\n        resolve(payload);\n      });\n    });\n  }\n\n  sendCustomRequest(request, options) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this11._connected) {\n        throw new Error(ERROR_SESSION_DISCONNECTED);\n      }\n\n      switch (request.method) {\n        case \"eth_accounts\":\n          return _this11.accounts;\n\n        case \"eth_chainId\":\n          return convertNumberToHex(_this11.chainId);\n\n        case \"eth_sendTransaction\":\n        case \"eth_signTransaction\":\n          if (request.params) {\n            request.params[0] = parseTransactionData(request.params[0]);\n          }\n\n          break;\n\n        case \"personal_sign\":\n          if (request.params) {\n            request.params = parsePersonalSign(request.params);\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      const formattedRequest = _this11._formatRequest(request);\n\n      const result = yield _this11._sendCallRequest(formattedRequest, options);\n      return result;\n    })();\n  }\n\n  approveRequest(response) {\n    if (isJsonRpcResponseSuccess(response)) {\n      const formattedResponse = this._formatResponse(response);\n\n      this._sendResponse(formattedResponse);\n    } else {\n      throw new Error(ERROR_MISSING_RESULT);\n    }\n  }\n\n  rejectRequest(response) {\n    if (isJsonRpcResponseError(response)) {\n      const formattedResponse = this._formatResponse(response);\n\n      this._sendResponse(formattedResponse);\n    } else {\n      throw new Error(ERROR_MISSING_ERROR);\n    }\n  }\n\n  transportClose() {\n    this._transport.close();\n  }\n\n  _sendRequest(request, options) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const callRequest = _this12._formatRequest(request);\n\n      const encryptionPayload = yield _this12._encrypt(callRequest);\n      const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== \"undefined\" ? options.topic : _this12.peerId;\n      const payload = JSON.stringify(encryptionPayload);\n      const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== \"undefined\" ? !options.forcePushNotification : isSilentPayload(callRequest);\n\n      _this12._transport.send(payload, topic, silent);\n    })();\n  }\n\n  _sendResponse(response) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      const encryptionPayload = yield _this13._encrypt(response);\n      const topic = _this13.peerId;\n      const payload = JSON.stringify(encryptionPayload);\n      const silent = true;\n\n      _this13._transport.send(payload, topic, silent);\n    })();\n  }\n\n  _sendSessionRequest(request, errorMsg, options) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      _this14._sendRequest(request, options);\n\n      _this14._subscribeToSessionResponse(request.id, errorMsg);\n    })();\n  }\n\n  _sendCallRequest(request, options) {\n    this._sendRequest(request, options);\n\n    this._eventManager.trigger({\n      event: \"call_request_sent\",\n      params: [{\n        request,\n        options\n      }]\n    });\n\n    return this._subscribeToCallResponse(request.id);\n  }\n\n  _formatRequest(request) {\n    if (typeof request.method === \"undefined\") {\n      throw new Error(ERROR_MISSING_METHOD);\n    }\n\n    const formattedRequest = {\n      id: typeof request.id === \"undefined\" ? payloadId() : request.id,\n      jsonrpc: \"2.0\",\n      method: request.method,\n      params: typeof request.params === \"undefined\" ? [] : request.params\n    };\n    return formattedRequest;\n  }\n\n  _formatResponse(response) {\n    if (typeof response.id === \"undefined\") {\n      throw new Error(ERROR_MISSING_ID);\n    }\n\n    const baseResponse = {\n      id: response.id,\n      jsonrpc: \"2.0\"\n    };\n\n    if (isJsonRpcResponseError(response)) {\n      const error = formatRpcError(response.error);\n      const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), {\n        error\n      });\n      return errorResponse;\n    } else if (isJsonRpcResponseSuccess(response)) {\n      const successResponse = Object.assign(Object.assign({}, baseResponse), response);\n      return successResponse;\n    }\n\n    throw new Error(ERROR_INVALID_RESPONSE);\n  }\n\n  _handleSessionDisconnect(errorMsg) {\n    const message = errorMsg || \"Session Disconnected\";\n\n    if (!this._connected) {\n      if (this._qrcodeModal) {\n        this._qrcodeModal.close();\n      }\n\n      removeLocal(mobileLinkChoiceKey);\n    }\n\n    if (this._connected) {\n      this._connected = false;\n    }\n\n    if (this._handshakeId) {\n      this._handshakeId = 0;\n    }\n\n    if (this._handshakeTopic) {\n      this._handshakeTopic = \"\";\n    }\n\n    if (this._peerId) {\n      this._peerId = \"\";\n    }\n\n    this._eventManager.trigger({\n      event: \"disconnect\",\n      params: [{\n        message\n      }]\n    });\n\n    this._removeStorageSession();\n\n    this.transportClose();\n  }\n\n  _handleSessionResponse(errorMsg, sessionParams) {\n    if (sessionParams) {\n      if (sessionParams.approved) {\n        if (!this._connected) {\n          this._connected = true;\n\n          if (sessionParams.chainId) {\n            this.chainId = sessionParams.chainId;\n          }\n\n          if (sessionParams.accounts) {\n            this.accounts = sessionParams.accounts;\n          }\n\n          if (sessionParams.peerId && !this.peerId) {\n            this.peerId = sessionParams.peerId;\n          }\n\n          if (sessionParams.peerMeta && !this.peerMeta) {\n            this.peerMeta = sessionParams.peerMeta;\n          }\n\n          this._eventManager.trigger({\n            event: \"connect\",\n            params: [{\n              peerId: this.peerId,\n              peerMeta: this.peerMeta,\n              chainId: this.chainId,\n              accounts: this.accounts\n            }]\n          });\n        } else {\n          if (sessionParams.chainId) {\n            this.chainId = sessionParams.chainId;\n          }\n\n          if (sessionParams.accounts) {\n            this.accounts = sessionParams.accounts;\n          }\n\n          this._eventManager.trigger({\n            event: \"session_update\",\n            params: [{\n              chainId: this.chainId,\n              accounts: this.accounts\n            }]\n          });\n        }\n\n        this._manageStorageSession();\n      } else {\n        this._handleSessionDisconnect(errorMsg);\n      }\n    } else {\n      this._handleSessionDisconnect(errorMsg);\n    }\n  }\n\n  _handleIncomingMessages(socketMessage) {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      const activeTopics = [_this15.clientId, _this15.handshakeTopic];\n\n      if (!activeTopics.includes(socketMessage.topic)) {\n        return;\n      }\n\n      let encryptionPayload;\n\n      try {\n        encryptionPayload = JSON.parse(socketMessage.payload);\n      } catch (error) {\n        return;\n      }\n\n      const payload = yield _this15._decrypt(encryptionPayload);\n\n      if (payload) {\n        _this15._eventManager.trigger(payload);\n      }\n    })();\n  }\n\n  _subscribeToSessionRequest() {\n    this._transport.subscribe(this.handshakeTopic);\n  }\n\n  _subscribeToResponse(id, callback) {\n    this.on(`response:${id}`, callback);\n  }\n\n  _subscribeToSessionResponse(id, errorMsg) {\n    this._subscribeToResponse(id, (error, payload) => {\n      if (error) {\n        this._handleSessionResponse(error.message);\n\n        return;\n      }\n\n      if (isJsonRpcResponseSuccess(payload)) {\n        this._handleSessionResponse(errorMsg, payload.result);\n      } else if (payload.error && payload.error.message) {\n        this._handleSessionResponse(payload.error.message);\n      } else {\n        this._handleSessionResponse(errorMsg);\n      }\n    });\n  }\n\n  _subscribeToCallResponse(id) {\n    return new Promise((resolve, reject) => {\n      this._subscribeToResponse(id, (error, payload) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        if (isJsonRpcResponseSuccess(payload)) {\n          resolve(payload.result);\n        } else if (payload.error && payload.error.message) {\n          reject(new Error(payload.error.message));\n        } else {\n          reject(new Error(ERROR_INVALID_RESPONSE));\n        }\n      });\n    });\n  }\n\n  _subscribeToInternalEvents() {\n    this.on(\"display_uri\", () => {\n      if (this._qrcodeModal) {\n        this._qrcodeModal.open(this.uri, () => {\n          this._eventManager.trigger({\n            event: \"modal_closed\",\n            params: []\n          });\n        }, this._qrcodeModalOptions);\n      }\n    });\n    this.on(\"connect\", () => {\n      if (this._qrcodeModal) {\n        this._qrcodeModal.close();\n      }\n    });\n    this.on(\"call_request_sent\", (error, payload) => {\n      const {\n        request\n      } = payload.params[0];\n\n      if (isMobile() && this._signingMethods.includes(request.method)) {\n        const mobileLinkUrl = getLocal(mobileLinkChoiceKey);\n\n        if (mobileLinkUrl) {\n          window.location.href = mobileLinkUrl.href;\n        }\n      }\n    });\n    this.on(\"wc_sessionRequest\", (error, payload) => {\n      if (error) {\n        this._eventManager.trigger({\n          event: \"error\",\n          params: [{\n            code: \"SESSION_REQUEST_ERROR\",\n            message: error.toString()\n          }]\n        });\n      }\n\n      this.handshakeId = payload.id;\n      this.peerId = payload.params[0].peerId;\n      this.peerMeta = payload.params[0].peerMeta;\n      const internalPayload = Object.assign(Object.assign({}, payload), {\n        method: \"session_request\"\n      });\n\n      this._eventManager.trigger(internalPayload);\n    });\n    this.on(\"wc_sessionUpdate\", (error, payload) => {\n      if (error) {\n        this._handleSessionResponse(error.message);\n      }\n\n      this._handleSessionResponse(\"Session disconnected\", payload.params[0]);\n    });\n  }\n\n  _initTransport() {\n    this._transport.on(\"message\", socketMessage => this._handleIncomingMessages(socketMessage));\n\n    this._transport.on(\"open\", () => this._eventManager.trigger({\n      event: \"transport_open\",\n      params: []\n    }));\n\n    this._transport.on(\"close\", () => this._eventManager.trigger({\n      event: \"transport_close\",\n      params: []\n    }));\n\n    this._transport.on(\"error\", () => this._eventManager.trigger({\n      event: \"transport_error\",\n      params: [\"Websocket connection failed\"]\n    }));\n\n    this._transport.open();\n  }\n\n  _formatUri() {\n    const protocol = this.protocol;\n    const handshakeTopic = this.handshakeTopic;\n    const version = this.version;\n    const bridge = encodeURIComponent(this.bridge);\n    const key = this.key;\n    const uri = `${protocol}:${handshakeTopic}@${version}?bridge=${bridge}&key=${key}`;\n    return uri;\n  }\n\n  _parseUri(uri) {\n    const result = parseWalletConnectUri(uri);\n\n    if (result.protocol === this.protocol) {\n      if (!result.handshakeTopic) {\n        throw Error(\"Invalid or missing handshakeTopic parameter value\");\n      }\n\n      const handshakeTopic = result.handshakeTopic;\n\n      if (!result.bridge) {\n        throw Error(\"Invalid or missing bridge url parameter value\");\n      }\n\n      const bridge = decodeURIComponent(result.bridge);\n\n      if (!result.key) {\n        throw Error(\"Invalid or missing key parameter value\");\n      }\n\n      const key = result.key;\n      return {\n        handshakeTopic,\n        bridge,\n        key\n      };\n    } else {\n      throw new Error(ERROR_INVALID_URI);\n    }\n  }\n\n  _generateKey() {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this16._cryptoLib) {\n        const result = yield _this16._cryptoLib.generateKey();\n        return result;\n      }\n\n      return null;\n    })();\n  }\n\n  _encrypt(data) {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      const key = _this17._key;\n\n      if (_this17._cryptoLib && key) {\n        const result = yield _this17._cryptoLib.encrypt(data, key);\n        return result;\n      }\n\n      return null;\n    })();\n  }\n\n  _decrypt(payload) {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      const key = _this18._key;\n\n      if (_this18._cryptoLib && key) {\n        const result = yield _this18._cryptoLib.decrypt(payload, key);\n        return result;\n      }\n\n      return null;\n    })();\n  }\n\n  _getStorageSession() {\n    let result = null;\n\n    if (this._sessionStorage) {\n      result = this._sessionStorage.getSession();\n    }\n\n    return result;\n  }\n\n  _setStorageSession() {\n    if (this._sessionStorage) {\n      this._sessionStorage.setSession(this.session);\n    }\n  }\n\n  _removeStorageSession() {\n    if (this._sessionStorage) {\n      this._sessionStorage.removeSession();\n    }\n  }\n\n  _manageStorageSession() {\n    if (this._connected) {\n      this._setStorageSession();\n    } else {\n      this._removeStorageSession();\n    }\n  }\n\n  _registerPushServer(pushServerOpts) {\n    if (!pushServerOpts.url || typeof pushServerOpts.url !== \"string\") {\n      throw Error(\"Invalid or missing pushServerOpts.url parameter value\");\n    }\n\n    if (!pushServerOpts.type || typeof pushServerOpts.type !== \"string\") {\n      throw Error(\"Invalid or missing pushServerOpts.type parameter value\");\n    }\n\n    if (!pushServerOpts.token || typeof pushServerOpts.token !== \"string\") {\n      throw Error(\"Invalid or missing pushServerOpts.token parameter value\");\n    }\n\n    const pushSubscription = {\n      bridge: this.bridge,\n      topic: this.clientId,\n      type: pushServerOpts.type,\n      token: pushServerOpts.token,\n      peerName: \"\",\n      language: pushServerOpts.language || \"\"\n    };\n    this.on(\"connect\", /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (error, payload) {\n        if (error) {\n          throw error;\n        }\n\n        if (pushServerOpts.peerMeta) {\n          const peerName = payload.params[0].peerMeta.name;\n          pushSubscription.peerName = peerName;\n        }\n\n        try {\n          const response = yield fetch(`${pushServerOpts.url}/new`, {\n            method: \"POST\",\n            headers: {\n              Accept: \"application/json\",\n              \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(pushSubscription)\n          });\n          const json = yield response.json();\n\n          if (!json.success) {\n            throw Error(\"Failed to register in Push Server\");\n          }\n        } catch (error) {\n          throw Error(\"Failed to register in Push Server\");\n        }\n      });\n\n      return function (_x3, _x4) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n  }\n\n}\n\nexport default Connector;","map":{"version":3,"sources":["/home/sparkout/Desktop/Hari/Sparkout/Angular/Angular_ZUKI/node_modules/@walletconnect/core/dist/esm/index.js"],"names":["parsePersonalSign","parseTransactionData","convertArrayBufferToHex","convertHexToArrayBuffer","getClientMeta","payloadId","uuid","formatRpcError","parseWalletConnectUri","convertNumberToHex","isJsonRpcResponseSuccess","isJsonRpcResponseError","isSilentPayload","getLocal","signingMethods","mobileLinkChoiceKey","isMobile","removeLocal","SocketTransport","ERROR_SESSION_CONNECTED","ERROR_SESSION_DISCONNECTED","ERROR_SESSION_REJECTED","ERROR_MISSING_JSON_RPC","ERROR_MISSING_RESULT","ERROR_MISSING_ERROR","ERROR_MISSING_METHOD","ERROR_MISSING_ID","ERROR_INVALID_RESPONSE","ERROR_INVALID_URI","ERROR_MISSING_REQUIRED","ERROR_QRCODE_MODAL_NOT_PROVIDED","ERROR_QRCODE_MODAL_USER_CLOSED","EventManager","SessionStorage","getBridgeUrl","Connector","constructor","opts","protocol","version","_bridge","_key","_clientId","_clientMeta","_peerId","_peerMeta","_handshakeId","_handshakeTopic","_connected","_accounts","_chainId","_networkId","_rpcUrl","_eventManager","connectorOpts","clientMeta","_cryptoLib","cryptoLib","_sessionStorage","sessionStorage","storageId","_qrcodeModal","qrcodeModal","_qrcodeModalOptions","qrcodeModalOptions","_signingMethods","bridge","uri","session","Error","_getStorageSession","handshakeId","_subscribeToSessionResponse","_transport","transport","url","subscriptions","clientId","_subscribeToInternalEvents","_initTransport","_subscribeToSessionRequest","pushServerOpts","_registerPushServer","value","key","peerId","peerMeta","handshakeTopic","_uri","_formatUri","_parseUri","chainId","networkId","accounts","rpcUrl","connected","pending","on","event","callback","eventEmitter","subscribe","off","unsubscribe","createInstantRequest","instantRequest","_generateKey","request","_formatRequest","method","params","id","trigger","endInstantRequest","killSession","result","_sendCallRequest","error","connect","createSession","Promise","resolve","reject","payload","_sendSessionRequest","topic","approveSession","sessionStatus","sessionParams","approved","response","jsonrpc","_sendResponse","_setStorageSession","rejectSession","sessionError","message","_formatResponse","_removeStorageSession","updateSession","_manageStorageSession","_sendRequest","_handleSessionDisconnect","sendTransaction","tx","parsedTx","signTransaction","signMessage","signPersonalMessage","signTypedData","updateChain","chainParams","unsafeSend","options","_subscribeToResponse","sendCustomRequest","formattedRequest","approveRequest","formattedResponse","rejectRequest","transportClose","close","callRequest","encryptionPayload","_encrypt","JSON","stringify","silent","forcePushNotification","send","errorMsg","_subscribeToCallResponse","baseResponse","errorResponse","Object","assign","successResponse","_handleSessionResponse","_handleIncomingMessages","socketMessage","activeTopics","includes","parse","_decrypt","open","mobileLinkUrl","window","location","href","code","toString","internalPayload","encodeURIComponent","decodeURIComponent","generateKey","data","encrypt","decrypt","getSession","setSession","removeSession","type","token","pushSubscription","peerName","language","name","fetch","headers","Accept","body","json","success"],"mappings":"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","sourcesContent":["import { parsePersonalSign, parseTransactionData, convertArrayBufferToHex, convertHexToArrayBuffer, getClientMeta, payloadId, uuid, formatRpcError, parseWalletConnectUri, convertNumberToHex, isJsonRpcResponseSuccess, isJsonRpcResponseError, isSilentPayload, getLocal, signingMethods, mobileLinkChoiceKey, isMobile, removeLocal, } from \"@walletconnect/utils\";\nimport SocketTransport from \"@walletconnect/socket-transport\";\nimport { ERROR_SESSION_CONNECTED, ERROR_SESSION_DISCONNECTED, ERROR_SESSION_REJECTED, ERROR_MISSING_JSON_RPC, ERROR_MISSING_RESULT, ERROR_MISSING_ERROR, ERROR_MISSING_METHOD, ERROR_MISSING_ID, ERROR_INVALID_RESPONSE, ERROR_INVALID_URI, ERROR_MISSING_REQUIRED, ERROR_QRCODE_MODAL_NOT_PROVIDED, ERROR_QRCODE_MODAL_USER_CLOSED, } from \"./errors\";\nimport EventManager from \"./events\";\nimport SessionStorage from \"./storage\";\nimport { getBridgeUrl } from \"./url\";\nclass Connector {\n    constructor(opts) {\n        this.protocol = \"wc\";\n        this.version = 1;\n        this._bridge = \"\";\n        this._key = null;\n        this._clientId = \"\";\n        this._clientMeta = null;\n        this._peerId = \"\";\n        this._peerMeta = null;\n        this._handshakeId = 0;\n        this._handshakeTopic = \"\";\n        this._connected = false;\n        this._accounts = [];\n        this._chainId = 0;\n        this._networkId = 0;\n        this._rpcUrl = \"\";\n        this._eventManager = new EventManager();\n        this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;\n        this._cryptoLib = opts.cryptoLib;\n        this._sessionStorage = opts.sessionStorage || new SessionStorage(opts.connectorOpts.storageId);\n        this._qrcodeModal = opts.connectorOpts.qrcodeModal;\n        this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;\n        this._signingMethods = [...signingMethods, ...(opts.connectorOpts.signingMethods || [])];\n        if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {\n            throw new Error(ERROR_MISSING_REQUIRED);\n        }\n        if (opts.connectorOpts.bridge) {\n            this.bridge = getBridgeUrl(opts.connectorOpts.bridge);\n        }\n        if (opts.connectorOpts.uri) {\n            this.uri = opts.connectorOpts.uri;\n        }\n        const session = opts.connectorOpts.session || this._getStorageSession();\n        if (session) {\n            this.session = session;\n        }\n        if (this.handshakeId) {\n            this._subscribeToSessionResponse(this.handshakeId, \"Session request rejected\");\n        }\n        this._transport =\n            opts.transport ||\n                new SocketTransport({\n                    protocol: this.protocol,\n                    version: this.version,\n                    url: this.bridge,\n                    subscriptions: [this.clientId],\n                });\n        this._subscribeToInternalEvents();\n        this._initTransport();\n        if (opts.connectorOpts.uri) {\n            this._subscribeToSessionRequest();\n        }\n        if (opts.pushServerOpts) {\n            this._registerPushServer(opts.pushServerOpts);\n        }\n    }\n    set bridge(value) {\n        if (!value) {\n            return;\n        }\n        this._bridge = value;\n    }\n    get bridge() {\n        return this._bridge;\n    }\n    set key(value) {\n        if (!value) {\n            return;\n        }\n        const key = convertHexToArrayBuffer(value);\n        this._key = key;\n    }\n    get key() {\n        if (this._key) {\n            const key = convertArrayBufferToHex(this._key, true);\n            return key;\n        }\n        return \"\";\n    }\n    set clientId(value) {\n        if (!value) {\n            return;\n        }\n        this._clientId = value;\n    }\n    get clientId() {\n        let clientId = this._clientId;\n        if (!clientId) {\n            clientId = this._clientId = uuid();\n        }\n        return this._clientId;\n    }\n    set peerId(value) {\n        if (!value) {\n            return;\n        }\n        this._peerId = value;\n    }\n    get peerId() {\n        return this._peerId;\n    }\n    set clientMeta(value) {\n    }\n    get clientMeta() {\n        let clientMeta = this._clientMeta;\n        if (!clientMeta) {\n            clientMeta = this._clientMeta = getClientMeta();\n        }\n        return clientMeta;\n    }\n    set peerMeta(value) {\n        this._peerMeta = value;\n    }\n    get peerMeta() {\n        const peerMeta = this._peerMeta;\n        return peerMeta;\n    }\n    set handshakeTopic(value) {\n        if (!value) {\n            return;\n        }\n        this._handshakeTopic = value;\n    }\n    get handshakeTopic() {\n        return this._handshakeTopic;\n    }\n    set handshakeId(value) {\n        if (!value) {\n            return;\n        }\n        this._handshakeId = value;\n    }\n    get handshakeId() {\n        return this._handshakeId;\n    }\n    get uri() {\n        const _uri = this._formatUri();\n        return _uri;\n    }\n    set uri(value) {\n        if (!value) {\n            return;\n        }\n        const { handshakeTopic, bridge, key } = this._parseUri(value);\n        this.handshakeTopic = handshakeTopic;\n        this.bridge = bridge;\n        this.key = key;\n    }\n    set chainId(value) {\n        this._chainId = value;\n    }\n    get chainId() {\n        const chainId = this._chainId;\n        return chainId;\n    }\n    set networkId(value) {\n        this._networkId = value;\n    }\n    get networkId() {\n        const networkId = this._networkId;\n        return networkId;\n    }\n    set accounts(value) {\n        this._accounts = value;\n    }\n    get accounts() {\n        const accounts = this._accounts;\n        return accounts;\n    }\n    set rpcUrl(value) {\n        this._rpcUrl = value;\n    }\n    get rpcUrl() {\n        const rpcUrl = this._rpcUrl;\n        return rpcUrl;\n    }\n    set connected(value) {\n    }\n    get connected() {\n        return this._connected;\n    }\n    set pending(value) {\n    }\n    get pending() {\n        return !!this._handshakeTopic;\n    }\n    get session() {\n        return {\n            connected: this.connected,\n            accounts: this.accounts,\n            chainId: this.chainId,\n            bridge: this.bridge,\n            key: this.key,\n            clientId: this.clientId,\n            clientMeta: this.clientMeta,\n            peerId: this.peerId,\n            peerMeta: this.peerMeta,\n            handshakeId: this.handshakeId,\n            handshakeTopic: this.handshakeTopic,\n        };\n    }\n    set session(value) {\n        if (!value) {\n            return;\n        }\n        this._connected = value.connected;\n        this.accounts = value.accounts;\n        this.chainId = value.chainId;\n        this.bridge = value.bridge;\n        this.key = value.key;\n        this.clientId = value.clientId;\n        this.clientMeta = value.clientMeta;\n        this.peerId = value.peerId;\n        this.peerMeta = value.peerMeta;\n        this.handshakeId = value.handshakeId;\n        this.handshakeTopic = value.handshakeTopic;\n    }\n    on(event, callback) {\n        const eventEmitter = {\n            event,\n            callback,\n        };\n        this._eventManager.subscribe(eventEmitter);\n    }\n    off(event) {\n        this._eventManager.unsubscribe(event);\n    }\n    async createInstantRequest(instantRequest) {\n        this._key = await this._generateKey();\n        const request = this._formatRequest({\n            method: \"wc_instantRequest\",\n            params: [\n                {\n                    peerId: this.clientId,\n                    peerMeta: this.clientMeta,\n                    request: this._formatRequest(instantRequest),\n                },\n            ],\n        });\n        this.handshakeId = request.id;\n        this.handshakeTopic = uuid();\n        this._eventManager.trigger({\n            event: \"display_uri\",\n            params: [this.uri],\n        });\n        this.on(\"modal_closed\", () => {\n            throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);\n        });\n        const endInstantRequest = () => {\n            this.killSession();\n        };\n        try {\n            const result = await this._sendCallRequest(request);\n            if (result) {\n                endInstantRequest();\n            }\n            return result;\n        }\n        catch (error) {\n            endInstantRequest();\n            throw error;\n        }\n    }\n    async connect(opts) {\n        if (!this._qrcodeModal) {\n            throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);\n        }\n        if (this.connected) {\n            return {\n                chainId: this.chainId,\n                accounts: this.accounts,\n            };\n        }\n        await this.createSession(opts);\n        return new Promise(async (resolve, reject) => {\n            this.on(\"modal_closed\", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));\n            this.on(\"connect\", (error, payload) => {\n                if (error) {\n                    return reject(error);\n                }\n                resolve(payload.params[0]);\n            });\n        });\n    }\n    async createSession(opts) {\n        if (this._connected) {\n            throw new Error(ERROR_SESSION_CONNECTED);\n        }\n        if (this.pending) {\n            return;\n        }\n        this._key = await this._generateKey();\n        const request = this._formatRequest({\n            method: \"wc_sessionRequest\",\n            params: [\n                {\n                    peerId: this.clientId,\n                    peerMeta: this.clientMeta,\n                    chainId: opts && opts.chainId ? opts.chainId : null,\n                },\n            ],\n        });\n        this.handshakeId = request.id;\n        this.handshakeTopic = uuid();\n        this._sendSessionRequest(request, \"Session update rejected\", {\n            topic: this.handshakeTopic,\n        });\n        this._eventManager.trigger({\n            event: \"display_uri\",\n            params: [this.uri],\n        });\n    }\n    approveSession(sessionStatus) {\n        if (this._connected) {\n            throw new Error(ERROR_SESSION_CONNECTED);\n        }\n        this.chainId = sessionStatus.chainId;\n        this.accounts = sessionStatus.accounts;\n        this.networkId = sessionStatus.networkId || 0;\n        this.rpcUrl = sessionStatus.rpcUrl || \"\";\n        const sessionParams = {\n            approved: true,\n            chainId: this.chainId,\n            networkId: this.networkId,\n            accounts: this.accounts,\n            rpcUrl: this.rpcUrl,\n            peerId: this.clientId,\n            peerMeta: this.clientMeta,\n        };\n        const response = {\n            id: this.handshakeId,\n            jsonrpc: \"2.0\",\n            result: sessionParams,\n        };\n        this._sendResponse(response);\n        this._connected = true;\n        this._setStorageSession();\n        this._eventManager.trigger({\n            event: \"connect\",\n            params: [\n                {\n                    peerId: this.peerId,\n                    peerMeta: this.peerMeta,\n                    chainId: this.chainId,\n                    accounts: this.accounts,\n                },\n            ],\n        });\n    }\n    rejectSession(sessionError) {\n        if (this._connected) {\n            throw new Error(ERROR_SESSION_CONNECTED);\n        }\n        const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;\n        const response = this._formatResponse({\n            id: this.handshakeId,\n            error: { message },\n        });\n        this._sendResponse(response);\n        this._connected = false;\n        this._eventManager.trigger({\n            event: \"disconnect\",\n            params: [{ message }],\n        });\n        this._removeStorageSession();\n    }\n    updateSession(sessionStatus) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        this.chainId = sessionStatus.chainId;\n        this.accounts = sessionStatus.accounts;\n        this.networkId = sessionStatus.networkId || 0;\n        this.rpcUrl = sessionStatus.rpcUrl || \"\";\n        const sessionParams = {\n            approved: true,\n            chainId: this.chainId,\n            networkId: this.networkId,\n            accounts: this.accounts,\n            rpcUrl: this.rpcUrl,\n        };\n        const request = this._formatRequest({\n            method: \"wc_sessionUpdate\",\n            params: [sessionParams],\n        });\n        this._sendSessionRequest(request, \"Session update rejected\");\n        this._eventManager.trigger({\n            event: \"session_update\",\n            params: [\n                {\n                    chainId: this.chainId,\n                    accounts: this.accounts,\n                },\n            ],\n        });\n        this._manageStorageSession();\n    }\n    async killSession(sessionError) {\n        const message = sessionError ? sessionError.message : \"Session Disconnected\";\n        const sessionParams = {\n            approved: false,\n            chainId: null,\n            networkId: null,\n            accounts: null,\n        };\n        const request = this._formatRequest({\n            method: \"wc_sessionUpdate\",\n            params: [sessionParams],\n        });\n        await this._sendRequest(request);\n        this._handleSessionDisconnect(message);\n    }\n    async sendTransaction(tx) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        const parsedTx = parseTransactionData(tx);\n        const request = this._formatRequest({\n            method: \"eth_sendTransaction\",\n            params: [parsedTx],\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    async signTransaction(tx) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        const parsedTx = parseTransactionData(tx);\n        const request = this._formatRequest({\n            method: \"eth_signTransaction\",\n            params: [parsedTx],\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    async signMessage(params) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        const request = this._formatRequest({\n            method: \"eth_sign\",\n            params,\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    async signPersonalMessage(params) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        params = parsePersonalSign(params);\n        const request = this._formatRequest({\n            method: \"personal_sign\",\n            params,\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    async signTypedData(params) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        const request = this._formatRequest({\n            method: \"eth_signTypedData\",\n            params,\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    async updateChain(chainParams) {\n        if (!this._connected) {\n            throw new Error(\"Session currently disconnected\");\n        }\n        const request = this._formatRequest({\n            method: \"wallet_updateChain\",\n            params: [chainParams],\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    unsafeSend(request, options) {\n        this._sendRequest(request, options);\n        this._eventManager.trigger({\n            event: \"call_request_sent\",\n            params: [{ request, options }],\n        });\n        return new Promise((resolve, reject) => {\n            this._subscribeToResponse(request.id, (error, payload) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                if (!payload) {\n                    throw new Error(ERROR_MISSING_JSON_RPC);\n                }\n                resolve(payload);\n            });\n        });\n    }\n    async sendCustomRequest(request, options) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        switch (request.method) {\n            case \"eth_accounts\":\n                return this.accounts;\n            case \"eth_chainId\":\n                return convertNumberToHex(this.chainId);\n            case \"eth_sendTransaction\":\n            case \"eth_signTransaction\":\n                if (request.params) {\n                    request.params[0] = parseTransactionData(request.params[0]);\n                }\n                break;\n            case \"personal_sign\":\n                if (request.params) {\n                    request.params = parsePersonalSign(request.params);\n                }\n                break;\n            default:\n                break;\n        }\n        const formattedRequest = this._formatRequest(request);\n        const result = await this._sendCallRequest(formattedRequest, options);\n        return result;\n    }\n    approveRequest(response) {\n        if (isJsonRpcResponseSuccess(response)) {\n            const formattedResponse = this._formatResponse(response);\n            this._sendResponse(formattedResponse);\n        }\n        else {\n            throw new Error(ERROR_MISSING_RESULT);\n        }\n    }\n    rejectRequest(response) {\n        if (isJsonRpcResponseError(response)) {\n            const formattedResponse = this._formatResponse(response);\n            this._sendResponse(formattedResponse);\n        }\n        else {\n            throw new Error(ERROR_MISSING_ERROR);\n        }\n    }\n    transportClose() {\n        this._transport.close();\n    }\n    async _sendRequest(request, options) {\n        const callRequest = this._formatRequest(request);\n        const encryptionPayload = await this._encrypt(callRequest);\n        const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== \"undefined\" ? options.topic : this.peerId;\n        const payload = JSON.stringify(encryptionPayload);\n        const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== \"undefined\"\n            ? !options.forcePushNotification\n            : isSilentPayload(callRequest);\n        this._transport.send(payload, topic, silent);\n    }\n    async _sendResponse(response) {\n        const encryptionPayload = await this._encrypt(response);\n        const topic = this.peerId;\n        const payload = JSON.stringify(encryptionPayload);\n        const silent = true;\n        this._transport.send(payload, topic, silent);\n    }\n    async _sendSessionRequest(request, errorMsg, options) {\n        this._sendRequest(request, options);\n        this._subscribeToSessionResponse(request.id, errorMsg);\n    }\n    _sendCallRequest(request, options) {\n        this._sendRequest(request, options);\n        this._eventManager.trigger({\n            event: \"call_request_sent\",\n            params: [{ request, options }],\n        });\n        return this._subscribeToCallResponse(request.id);\n    }\n    _formatRequest(request) {\n        if (typeof request.method === \"undefined\") {\n            throw new Error(ERROR_MISSING_METHOD);\n        }\n        const formattedRequest = {\n            id: typeof request.id === \"undefined\" ? payloadId() : request.id,\n            jsonrpc: \"2.0\",\n            method: request.method,\n            params: typeof request.params === \"undefined\" ? [] : request.params,\n        };\n        return formattedRequest;\n    }\n    _formatResponse(response) {\n        if (typeof response.id === \"undefined\") {\n            throw new Error(ERROR_MISSING_ID);\n        }\n        const baseResponse = { id: response.id, jsonrpc: \"2.0\" };\n        if (isJsonRpcResponseError(response)) {\n            const error = formatRpcError(response.error);\n            const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });\n            return errorResponse;\n        }\n        else if (isJsonRpcResponseSuccess(response)) {\n            const successResponse = Object.assign(Object.assign({}, baseResponse), response);\n            return successResponse;\n        }\n        throw new Error(ERROR_INVALID_RESPONSE);\n    }\n    _handleSessionDisconnect(errorMsg) {\n        const message = errorMsg || \"Session Disconnected\";\n        if (!this._connected) {\n            if (this._qrcodeModal) {\n                this._qrcodeModal.close();\n            }\n            removeLocal(mobileLinkChoiceKey);\n        }\n        if (this._connected) {\n            this._connected = false;\n        }\n        if (this._handshakeId) {\n            this._handshakeId = 0;\n        }\n        if (this._handshakeTopic) {\n            this._handshakeTopic = \"\";\n        }\n        if (this._peerId) {\n            this._peerId = \"\";\n        }\n        this._eventManager.trigger({\n            event: \"disconnect\",\n            params: [{ message }],\n        });\n        this._removeStorageSession();\n        this.transportClose();\n    }\n    _handleSessionResponse(errorMsg, sessionParams) {\n        if (sessionParams) {\n            if (sessionParams.approved) {\n                if (!this._connected) {\n                    this._connected = true;\n                    if (sessionParams.chainId) {\n                        this.chainId = sessionParams.chainId;\n                    }\n                    if (sessionParams.accounts) {\n                        this.accounts = sessionParams.accounts;\n                    }\n                    if (sessionParams.peerId && !this.peerId) {\n                        this.peerId = sessionParams.peerId;\n                    }\n                    if (sessionParams.peerMeta && !this.peerMeta) {\n                        this.peerMeta = sessionParams.peerMeta;\n                    }\n                    this._eventManager.trigger({\n                        event: \"connect\",\n                        params: [\n                            {\n                                peerId: this.peerId,\n                                peerMeta: this.peerMeta,\n                                chainId: this.chainId,\n                                accounts: this.accounts,\n                            },\n                        ],\n                    });\n                }\n                else {\n                    if (sessionParams.chainId) {\n                        this.chainId = sessionParams.chainId;\n                    }\n                    if (sessionParams.accounts) {\n                        this.accounts = sessionParams.accounts;\n                    }\n                    this._eventManager.trigger({\n                        event: \"session_update\",\n                        params: [\n                            {\n                                chainId: this.chainId,\n                                accounts: this.accounts,\n                            },\n                        ],\n                    });\n                }\n                this._manageStorageSession();\n            }\n            else {\n                this._handleSessionDisconnect(errorMsg);\n            }\n        }\n        else {\n            this._handleSessionDisconnect(errorMsg);\n        }\n    }\n    async _handleIncomingMessages(socketMessage) {\n        const activeTopics = [this.clientId, this.handshakeTopic];\n        if (!activeTopics.includes(socketMessage.topic)) {\n            return;\n        }\n        let encryptionPayload;\n        try {\n            encryptionPayload = JSON.parse(socketMessage.payload);\n        }\n        catch (error) {\n            return;\n        }\n        const payload = await this._decrypt(encryptionPayload);\n        if (payload) {\n            this._eventManager.trigger(payload);\n        }\n    }\n    _subscribeToSessionRequest() {\n        this._transport.subscribe(this.handshakeTopic);\n    }\n    _subscribeToResponse(id, callback) {\n        this.on(`response:${id}`, callback);\n    }\n    _subscribeToSessionResponse(id, errorMsg) {\n        this._subscribeToResponse(id, (error, payload) => {\n            if (error) {\n                this._handleSessionResponse(error.message);\n                return;\n            }\n            if (isJsonRpcResponseSuccess(payload)) {\n                this._handleSessionResponse(errorMsg, payload.result);\n            }\n            else if (payload.error && payload.error.message) {\n                this._handleSessionResponse(payload.error.message);\n            }\n            else {\n                this._handleSessionResponse(errorMsg);\n            }\n        });\n    }\n    _subscribeToCallResponse(id) {\n        return new Promise((resolve, reject) => {\n            this._subscribeToResponse(id, (error, payload) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                if (isJsonRpcResponseSuccess(payload)) {\n                    resolve(payload.result);\n                }\n                else if (payload.error && payload.error.message) {\n                    reject(new Error(payload.error.message));\n                }\n                else {\n                    reject(new Error(ERROR_INVALID_RESPONSE));\n                }\n            });\n        });\n    }\n    _subscribeToInternalEvents() {\n        this.on(\"display_uri\", () => {\n            if (this._qrcodeModal) {\n                this._qrcodeModal.open(this.uri, () => {\n                    this._eventManager.trigger({\n                        event: \"modal_closed\",\n                        params: [],\n                    });\n                }, this._qrcodeModalOptions);\n            }\n        });\n        this.on(\"connect\", () => {\n            if (this._qrcodeModal) {\n                this._qrcodeModal.close();\n            }\n        });\n        this.on(\"call_request_sent\", (error, payload) => {\n            const { request } = payload.params[0];\n            if (isMobile() && this._signingMethods.includes(request.method)) {\n                const mobileLinkUrl = getLocal(mobileLinkChoiceKey);\n                if (mobileLinkUrl) {\n                    window.location.href = mobileLinkUrl.href;\n                }\n            }\n        });\n        this.on(\"wc_sessionRequest\", (error, payload) => {\n            if (error) {\n                this._eventManager.trigger({\n                    event: \"error\",\n                    params: [\n                        {\n                            code: \"SESSION_REQUEST_ERROR\",\n                            message: error.toString(),\n                        },\n                    ],\n                });\n            }\n            this.handshakeId = payload.id;\n            this.peerId = payload.params[0].peerId;\n            this.peerMeta = payload.params[0].peerMeta;\n            const internalPayload = Object.assign(Object.assign({}, payload), { method: \"session_request\" });\n            this._eventManager.trigger(internalPayload);\n        });\n        this.on(\"wc_sessionUpdate\", (error, payload) => {\n            if (error) {\n                this._handleSessionResponse(error.message);\n            }\n            this._handleSessionResponse(\"Session disconnected\", payload.params[0]);\n        });\n    }\n    _initTransport() {\n        this._transport.on(\"message\", (socketMessage) => this._handleIncomingMessages(socketMessage));\n        this._transport.on(\"open\", () => this._eventManager.trigger({ event: \"transport_open\", params: [] }));\n        this._transport.on(\"close\", () => this._eventManager.trigger({ event: \"transport_close\", params: [] }));\n        this._transport.on(\"error\", () => this._eventManager.trigger({\n            event: \"transport_error\",\n            params: [\"Websocket connection failed\"],\n        }));\n        this._transport.open();\n    }\n    _formatUri() {\n        const protocol = this.protocol;\n        const handshakeTopic = this.handshakeTopic;\n        const version = this.version;\n        const bridge = encodeURIComponent(this.bridge);\n        const key = this.key;\n        const uri = `${protocol}:${handshakeTopic}@${version}?bridge=${bridge}&key=${key}`;\n        return uri;\n    }\n    _parseUri(uri) {\n        const result = parseWalletConnectUri(uri);\n        if (result.protocol === this.protocol) {\n            if (!result.handshakeTopic) {\n                throw Error(\"Invalid or missing handshakeTopic parameter value\");\n            }\n            const handshakeTopic = result.handshakeTopic;\n            if (!result.bridge) {\n                throw Error(\"Invalid or missing bridge url parameter value\");\n            }\n            const bridge = decodeURIComponent(result.bridge);\n            if (!result.key) {\n                throw Error(\"Invalid or missing key parameter value\");\n            }\n            const key = result.key;\n            return { handshakeTopic, bridge, key };\n        }\n        else {\n            throw new Error(ERROR_INVALID_URI);\n        }\n    }\n    async _generateKey() {\n        if (this._cryptoLib) {\n            const result = await this._cryptoLib.generateKey();\n            return result;\n        }\n        return null;\n    }\n    async _encrypt(data) {\n        const key = this._key;\n        if (this._cryptoLib && key) {\n            const result = await this._cryptoLib.encrypt(data, key);\n            return result;\n        }\n        return null;\n    }\n    async _decrypt(payload) {\n        const key = this._key;\n        if (this._cryptoLib && key) {\n            const result = await this._cryptoLib.decrypt(payload, key);\n            return result;\n        }\n        return null;\n    }\n    _getStorageSession() {\n        let result = null;\n        if (this._sessionStorage) {\n            result = this._sessionStorage.getSession();\n        }\n        return result;\n    }\n    _setStorageSession() {\n        if (this._sessionStorage) {\n            this._sessionStorage.setSession(this.session);\n        }\n    }\n    _removeStorageSession() {\n        if (this._sessionStorage) {\n            this._sessionStorage.removeSession();\n        }\n    }\n    _manageStorageSession() {\n        if (this._connected) {\n            this._setStorageSession();\n        }\n        else {\n            this._removeStorageSession();\n        }\n    }\n    _registerPushServer(pushServerOpts) {\n        if (!pushServerOpts.url || typeof pushServerOpts.url !== \"string\") {\n            throw Error(\"Invalid or missing pushServerOpts.url parameter value\");\n        }\n        if (!pushServerOpts.type || typeof pushServerOpts.type !== \"string\") {\n            throw Error(\"Invalid or missing pushServerOpts.type parameter value\");\n        }\n        if (!pushServerOpts.token || typeof pushServerOpts.token !== \"string\") {\n            throw Error(\"Invalid or missing pushServerOpts.token parameter value\");\n        }\n        const pushSubscription = {\n            bridge: this.bridge,\n            topic: this.clientId,\n            type: pushServerOpts.type,\n            token: pushServerOpts.token,\n            peerName: \"\",\n            language: pushServerOpts.language || \"\",\n        };\n        this.on(\"connect\", async (error, payload) => {\n            if (error) {\n                throw error;\n            }\n            if (pushServerOpts.peerMeta) {\n                const peerName = payload.params[0].peerMeta.name;\n                pushSubscription.peerName = peerName;\n            }\n            try {\n                const response = await fetch(`${pushServerOpts.url}/new`, {\n                    method: \"POST\",\n                    headers: {\n                        Accept: \"application/json\",\n                        \"Content-Type\": \"application/json\",\n                    },\n                    body: JSON.stringify(pushSubscription),\n                });\n                const json = await response.json();\n                if (!json.success) {\n                    throw Error(\"Failed to register in Push Server\");\n                }\n            }\n            catch (error) {\n                throw Error(\"Failed to register in Push Server\");\n            }\n        });\n    }\n}\nexport default Connector;\n"]},"metadata":{},"sourceType":"module"}